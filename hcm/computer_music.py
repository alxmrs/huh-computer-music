import numpy as np
from matplotlib import pyplot as plt


################################################################################
from scipy.io import wavfile

def wav_read(filename):
    """
    Import .wav files from current directory.
    """
    return wavfile.read(filename)[1]

def wav_write(filename, sample_rate, file):
    """
    Export array to .wav file in current directory.
    """
    return wavfile.write(filename, sample_rate, file)


################################################################################
def time(t0, T, sample_rate):
    """
    Just np.linspace()
    t = [t[0], t[1], t[2], ..., t[n], ..., t[N]].
    t[N] = t0 + N*dt = T
    dt = 1/sample_rate
    """
    t = np.linspace(t0, t0+T, num=T*sample_rate)
    return t

################################################################################


def sine(t, f):
    """
    Sine wave with frequency f, amplitude 1.
    """
    return np.sin(2*np.pi*f*t)

def square(t, f):
    """
    Square wave with frequency f, amplitude 1.
    """
    return np.sign(np.sin(2*np.pi*f*t))

def triangle(t, f):
    """
    Triangle wave with frequency f, amplitude 1.
    """
    return (2/np.pi)*np.arcsin(np.sin(2*np.pi*f*t))
################################################################################


# allow voltage control of oscillator frequency
# here freq is now an array w/ same length as t
def VCO(t, f, osc):
    """
    Allows control of frequency in time.
    f is now a 1-D array with same length as t, so that the frequency can be
    specified at each point in time.
    Argument 'osc' can be sine, square, or triangle.
    """
    N = len(t);
    output = np.zeros(N);
    for n in range(0, N):
        output[n] = osc(t[n], f[n])
    return output


################################################################################
def white_noise(t):
    """
    White noise generated by sampling at random from a uniform distribution.
    """
    N = len(t);
    x = np.random.uniform(-1.0, 1.0, N)
    return x


def brownian_noise(t):
    """
    Brown noise generated
    """
    N = len(t);
    dx = np.zeros(N);
    for n in range(0, N):
        dx[n] = np.random.normal(0, scale=np.sqrt(t[n]))
    x = np.zeros(N);
    for n in range(1, len(x)):
        x[n] = x[n-1] + dx[n]
    return x

# GENERATE PINK NOISE


################################################################################

def lorenz(t, time_scale):
    """
    Parameters s, r, b are fixed.
    Initial conditions also fixed, but with slight random perturbation to keep it interesting.
    """
    # params
    s = 10;
    r = 28;
    b = 8/3.;
    # initialize state vector
    X0 = [2, 3, 4]
    X = np.zeros([len(X0), len(t)])
    # label state variables
    x = X[0];
    y = X[1];
    z = X[2];
    # assign initial condition
    X[:, 0] = X0;
    # define time step
    dt = (t[1] - t[0])*time_scale;
    # equations of motion
    for n in range(0, len(t)-1):
        x[n+1] = x[n] + dt * (s*(y[n] - x[n]))
        y[n+1] = y[n] + dt * (r*x[n] - y[n] - x[n]*z[n])
        z[n+1] = z[n] + dt * (x[n]*y[n] - b*z[n])
    # normalize
    x = normalize(x);
    y = normalize(y);
    z = normalize(z);
    return x,y,z


################################################################################


def normalize(signal):
    """
    Restrict the range of a signal to the closed interval [-1.0, 1.0].
    """
    normalized_signal = signal/max(signal.max(), signal.min(), key=abs)
    return normalized_signal


################################################################################

def AM(signal, modulation):
    """
    Amplitude modulation of two signals by pairwise multiplication.
    """
    return np.multiply(signal, modulation)


################################################################################
# hold = downsampled rate, or the number of times per second you want to sample
def sample_and_hold(signal, sample_rate, hold):
    """
    Samples
    """
    inc = int(sample_rate/hold)
    samples = signal[0::inc]
    new_signal = np.zeros([len(samples), inc])
    for i in range(0, len(samples)):
        new_signal[i, :] = samples[i]
    return np.concatenate(new_signal)
################################################################################
def scale_constructor(f0, key, num_octaves):
    """
    Makes a vector of frequencies to go over
    """
    init_octave = np.zeros(len(key))
    for n in range(0, len(init_octave)):
        init_octave[n] = f0 * 2**(key[n]/12.)
    all_octaves = np.zeros([num_octaves, len(key)])
    for i in range(0, num_octaves):
        all_octaves[i] = 2**i * init_octave
    return np.concatenate(all_octaves)
################################################################################
from scipy.interpolate import interp1d

def frequency_map(signal, scale):
    """
    Takes a control voltage (CV) signal, whose range is on [-1.0, 1.0] and maps
    it to a corresponding position on the scale.
    Returns an array of
    """
    interp = interp1d([-1, 1], [0, len(scale)-1])
    f = np.zeros(len(signal))
    for n in range(0, len(signal)):
        index = int(interp(signal[n]))
        f[n] = scale[index]
    return f

################################################################################
################################################################################

def tempo_to_frequency(tempo, note_duration):
    """
    Given tempo (in BPM) and note duration, gives corresponding frequency.
    """
    # assign appropriate numerical factor to note type
    if note_duration == 'whole':
        note = -2.0;
    if note_duration == 'half':
        note = -1.0;
    if note_duration == 'quarter':
        note = 0.0;
    if note_duration == 'eighth':
        note = 1.0;
    if note_duration == 'sixteenth':
        note = 2.0;
    # calclulate frequency
    frequency = (tempo/60.) * 2**note  # [Hz]
    return frequency

################################################################################


def add_channels(signals):
    return np.array(np.vstack(signals)).T
