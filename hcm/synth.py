def time(t0, T, sample_rate):
    """Just np.linspace()

    t = [t[0], t[1], t[2], ..., t[n], ..., t[N]].
    t[N] = t0 + N*dt = T
    dt = 1/sample_rate
    """
    t = np.linspace(t0, t0 + T, num=T * sample_rate, dtype=np.float32)
    return t


def normalize(signal):
    """Restrict the range of a signal to the closed interval [-1.0, 1.0]. """
    normalized_signal = signal / max(signal.max(), signal.min(), key=abs)
    return normalized_signal


# OSCILLATORS

def sine_wave(t, f, phi=0, A=1):
    """
    Sine wave: frequency, amplitude, and phase-adjustable oscillator.

    Parameters
    ----------
    t : 1-D array
        Time.
    f : scalar or 1-D array
        Frequency.
    A : scalar or 1-D array
        Amplitude, defaults to 1.
    phi : scalar or 1-D array
        Phase, defaults to 0.

    Returns
    ----------
    out : 1-D array
        Time series array of sine wave.
    """
    x = np.multiply(A, np.sin(np.add(np.multiply(2*np.pi*f, t), phi)))
    return x


def square_wave(t, f, d=.5, phi=0, A=1):
    """
    Square wave: frequency, duty cycle, amplitude, and phase-adjustable oscillator.

    Parameters
    ----------
    t : 1-D array
        Time.
    f : scalar or 1-D array
        Frequency.
    d : scalar or 1-D array
        Duty cycle. Values must fall within [0,1].
        Set d=0.5 for square wave.
    A : scalar or 1-D array
        Amplitude, defaults to 1.
    phi : scalar or 1-D array
        Phase, defaults to 0.

    Returns
    ----------
    out : 1-D array
        Time series array of square or pulse wave.

    """
    x = np.multiply(A, signal.square(np.add(np.multiply(2*np.pi*f, t), phi), d))
    return x


def sawtooth_wave(t, f, d=0, phi=0, A=1):
    """
    Sawtooth wave: frequency, duty cycle, amplitude, and phase-adjustable oscillator.

    Parameters
    ----------
    t : 1-D array
        Time.
    f : scalar or 1-D array
        Frequency.
    d : scalar or 1-D array
        Duty cycle. Values must fall within [0,1].
        Set d=0.5 for triangle wave. d=0 for negative slope sawtooth, d=1 for positive slope sawtooth.
    A : scalar or 1-D array
        Amplitude, defaults to 1.
    phi : scalar or 1-D array
        Phase, defaults to 0.

    Returns
    ----------
    out : 1-D array
        Time series array of triangle or sawtooth wave.

    """
    x = np.multiply(A, signal.sawtooth(np.add(np.multiply(2*np.pi*f, t), phi), d))
    return x



def white_noise(t):
    """White noise generated by sampling at random from a uniform distribution.

    """
    N = len(t)
    x = np.random.uniform(-1.0, 1.0, N)
    return x


def brownian_noise(t):
    """Brown noise generated """
    N = len(t)
    dx = np.zeros(N)
    for n in range(0, N):
        dx[n] = np.random.normal(0, scale=np.sqrt(t[n]))
    x = np.zeros(N)
    for n in range(1, len(x)):
        x[n] = x[n - 1] + dx[n]
    return x



# FILTERS: lowpass, highpass, bandpass...

# what are acceptable values for fc, k?
# need a wrapper to take values in range [0,1]?
def lowpass(x, fc, k, sample_rate=R):
    # state variables
    y1 = np.zeros(len(x))
    y2 = np.zeros(len(y1))
    y3 = np.zeros(len(y2))
    y4 = np.zeros(len(y3))
    # define angular frequency
    omega = np.multiply(2*np.pi, fc)
    # initial conditions
    y1[0] = omega[0]/(1+omega[0]) * x[0]
    y2[0] = omega[0]/(1+omega[0]) * y1[0]
    y3[0] = omega[0]/(1+omega[0]) * y2[0]
    y4[0] = omega[0]/(1+omega[0]) * y3[0]
    dt = 1/sample_rate
    for n in range(len(x)-1):
        y1[n+1] = y1[n] + dt * omega[n] * (x[n] - y1[n] - k[n] * y4[n])
        y2[n+1] = y2[n] + dt * omega[n] * (y1[n] - y2[n])
        y3[n+1] = y3[n] + dt * omega[n] * (y2[n] - y3[n])
        y4[n+1] = y4[n] + dt * omega[n] * (y3[n] - y4[n])
    return y4

# what are acceptable values for fc, k?
# need a wrapper to take values in range [0,1]?
def highpass(x, fc, k, sample_rate=R):
    # state variables
    y1 = np.zeros(len(x))
    y2 = np.zeros(len(y1))
    y3 = np.zeros(len(y2))
    y4 = np.zeros(len(y3))
    # initial conditions
    y1[0] = x[0]
    y2[0] = y1[0]
    y3[0] = y2[0]
    y4[0] = y3[0]
    dt=1/sample_rate
    alpha = 1/(2*np.pi*dt*fc+1)
    for n in range(len(x)-1):
        y1[n+1] = alpha[n] * (y1[n] + x[n+1] - x[n] - k[n] * y4[n])
        y2[n+1] = alpha[n] * (y2[n] + y1[n+1] - y1[n])
        y3[n+1] = alpha[n] * (y3[n] + y2[n+1] - y2[n])
        y4[n+1] = alpha[n] * (y4[n] + y3[n+1] - y3[n])
    return y4
